<!DOCTYPE html>
<html>

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pong wars | Koen van Gilst</title>
  <meta name="description"
    content="The eternal battle between day and night, good and bad. Written in JavaScript with some HTML & CSS in one index.html. Feel free to reuse the code and create your own version." />
  <link rel="canonical" href="https://pong-wars.koenvangilst.nl/" />
  <link rel="author" href="https://koenvangilst.nl" />
  <meta name="theme-color" content="#172B36" />
  <meta name="creator" content="Koen van Gilst" />
  <style>
    html {
      height: 100%;
    }

    body {
      height: 100%;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      background: linear-gradient(to bottom, #172b36 0%, #d9e8e3 100%);
    }

    #container {
      display: flex;
      align-items: center;
      flex-direction: column;
      width: min(70vh, 80%);
      max-width: 600px;
      height: 100%;
    }

    canvas {
      display: block;
      border-radius: 4px;
      overflow: hidden;
      width: 100%;
      margin-top: auto;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
    }

    #score {
      font-family: monospace;
      margin-top: 30px;
      font-size: 16px;
      padding-left: 20px;
      color: #172b36;
    }

    #made {
      text-align: center;
      line-height: 1.5;
      font-family: monospace;
      margin-top: auto;
      margin-bottom: 20px;
      font-size: 10px;
    }

    #made a {
      color: #172b36;
    }
  </style>
</head>

<body>
  <div id="container">
    <canvas id="pongCanvas" width="600" height="600"></canvas>
    <div id="score"></div>
    <p id="made">
      made by
      <a href="https://koenvangilst.nl/labs/pong-wars">Koen van Gilst</a> |
      source on
      <a href="https://github.com/vnglst/pong-wars">github</a>
    </p>
  </div>
</body>

<script>
  // Source palette: https://twitter.com/AlexCristache/status/1738610343499157872
  // Idea for Pong wars: https://twitter.com/nicolasdnl/status/1749715070928433161

  const colorPalette = {
    ArcticPowder: "#F1F6F4",
    MysticMint: "#D9E8E3",
    Forsythia: "#FFC801",
    DeepSaffron: "#FF9932",
    NocturnalExpedition: "#114C5A",
    OceanicNoir: "#172B36",
  };

  const canvas = document.getElementById("pongCanvas");
  const ctx = canvas.getContext("2d");
  const scoreElement = document.getElementById("score");

  const DAY_COLOR = colorPalette.MysticMint;
  const DAY_BALL_COLOR = colorPalette.NocturnalExpedition;
  const NIGHT_COLOR = colorPalette.NocturnalExpedition;
  const NIGHT_BALL_COLOR = colorPalette.MysticMint;
  const NEITHER_COLOR = colorPalette.ArcticPowder;
  const WALL_COLOR = colorPalette.DeepSaffron;
  const HEXAGON_SIZE = 20; // 隣の六角形との中心間距離
  const BALL_RADIUS = HEXAGON_SIZE / 1.5;

  const MID_SPEED = 1.5
  const MIN_SPEED = MID_SPEED / 2;
  const MAX_SPEED = MID_SPEED * 1.5;

  const HEXAGON_MAP_LEVEL = 5;


  let dayScore = 0;
  let nightScore = 0;


  // hexagon: {i, x, y, color}
  const hexagons = getHexagons(HEXAGON_MAP_LEVEL, HEXAGON_SIZE);
  const numHexagons = hexagons.length;

  const angle0 = Math.random() * Math.PI * 2;
  const angle1 = Math.random() * Math.PI * 2;


  const balls = [
    {
      x: -canvas.width / 4,
      y: 0,
      dx: MID_SPEED * Math.cos(angle0),
      dy: MID_SPEED * Math.sin(angle0),
      reverseColor: DAY_COLOR,
      ballColor: DAY_BALL_COLOR,
    },
    {
      x: canvas.width / 4,
      y: 0,
      dx: MID_SPEED * Math.cos(angle1),
      dy: MID_SPEED * Math.sin(angle1),
      reverseColor: NIGHT_COLOR,
      ballColor: NIGHT_BALL_COLOR,
    },
  ];

  let iteration = 0;

  function drawBall(ball) {
    ctx.beginPath();
    ctx.arc(ball.x + canvas.width / 2, ball.y + canvas.height / 2, BALL_RADIUS, 0, Math.PI * 2, false);
    ctx.fillStyle = ball.ballColor;
    ctx.fill();
    ctx.closePath();
  }

  function isOverlapping(r, R, hexCenter, circleCenter) {
    const [hx, hy] = hexCenter;
    const [cx, cy] = circleCenter;

    // 正六角形の中心と円の中心の距離 > 正六角形の中心から頂点までの距離 + 円の半径 のときは重なっていない
    if (Math.sqrt((hx - cx) ** 2 + (hy - cy) ** 2) > r / Math.cos(Math.PI / 6) + R) {
      return false;
    }

    // 正六角形の頂点の座標を計算する
    const vertices = [];
    for (let i = 0; i < 6; i++) {
      const angle = (60 * i) * Math.PI / 180;
      const vx = hx + r * Math.cos(angle + Math.PI / 6);
      const vy = hy + r * Math.sin(angle + Math.PI / 6);
      vertices.push([vx, vy]);
    }

    // 円の中心が正六角形の内部にあるかチェックする
    function isPointInHexagon(px, py) {
      const translatedX = px - hx;
      const translatedY = py - hy;

      const q2 = Math.sqrt(3) * Math.abs(translatedY);
      if (q2 > 3 * r) {
        return false;
      }
      return Math.abs(translatedX) <= Math.min(r, 2 * r - q2);
    }

    if (isPointInHexagon(cx, cy)) {
      return true;
    }

    // 線分と円の交差をチェックする関数
    function lineCircleIntersection(x1, y1, x2, y2, cx, cy, r) {
      const acx = cx - x1;
      const acy = cy - y1;
      const abx = x2 - x1;
      const aby = y2 - y1;

      const ab_ab = abx * abx + aby * aby;
      const ab_ac = abx * acx + aby * acy;
      const t = ab_ac / ab_ab;

      const hpx = x1 + t * abx;
      const hpy = y1 + t * aby;
      const hcx = hpx - cx;
      const hcy = hpy - cy;

      if (t >= 0 && t <= 1) {
        return hcx * hcx + hcy * hcy <= r * r;
      } else if (t < 0) {
        return acx * acx + acy * acy <= r * r;
      } else {
        const bcx = cx - x2;
        const bcy = cy - y2;
        return bcx * bcx + bcy * bcy <= r * r;
      }
    }

    // 正六角形の各辺が円と交差しているかチェック
    for (let i = 0; i < 6; i++) {
      const [x1, y1] = vertices[i];
      const [x2, y2] = vertices[(i + 1) % 6];
      if (lineCircleIntersection(x1, y1, x2, y2, cx, cy, R)) {
        return true;
      }
    }

    return false;
  }


  function checkCollision(ball) {
    // ボールが重なっている六角形を探す
    const collisionHexagons = [];
    for (let i = 0; i < numHexagons; i++) {
      const hex = hexagons[i];
      if (isOverlapping(HEXAGON_SIZE, BALL_RADIUS, [hex.x, hex.y], [ball.x, ball.y])) {
        collisionHexagons.push(hex);
      }
    }
    if (collisionHexagons.length < 2) {
      return;
    }

    let fst = Number.MAX_VALUE;
    let fsti = -1;
    let snd = Number.MAX_VALUE;
    let sndi = -1;
    for (let j = 0; j < collisionHexagons.length; j++) {
      const hex = collisionHexagons[j];
      const dist = Math.sqrt((ball.x - hex.x) ** 2 + (ball.y - hex.y) ** 2);
      if (dist < fst) {
        snd = fst;
        sndi = fsti;
        fst = dist;
        fsti = j;
      } else if (dist < snd) {
        snd = dist;
        sndi = j;
      }
    }

    const current = collisionHexagons[fsti];
    const next = collisionHexagons[sndi];

    // next - currentのベクトル(= 壁の法線ベクトル)
    const nx = next.x - current.x;
    const ny = next.y - current.y;


    if (next.color === WALL_COLOR) {
      console.log("collision with wall")
      reflect({ x: nx, y: ny }, ball);

      if (collisionHexagons.length >= 3) {
        console.log(collisionHexagons);
      }
    } else if (next.color === NEITHER_COLOR) {
      console.log("collision with neither")
      next.color = ball.reverseColor;
    } else if (next.color !== ball.reverseColor) {
      console.log("collision with opposite color")
      next.color = ball.reverseColor;

      reflect({ x: nx, y: ny }, ball);
    }

    // 壁の法線ベクトルnvがわかっているときの、ボールの跳ね返り後の速度ベクトルを計算する関数
    // nv: 壁の法線ベクトル
    // ball: ボールのオブジェクト
    // 反射ベクトル = 入射ベクトル - 2 * (入射ベクトル・法線ベクトル) * 法線ベクトル

    function reflect(nv, ball) {
      const nvLength = Math.sqrt(nv.x ** 2 + nv.y ** 2);
      const nvUnit = { x: nv.x / nvLength, y: nv.y / nvLength };

      const dot = ball.dx * nvUnit.x + ball.dy * nvUnit.y;
      const reflectX = ball.dx - 2 * dot * nvUnit.x;
      const reflectY = ball.dy - 2 * dot * nvUnit.y;

      ball.dx = reflectX;
      ball.dy = reflectY;
    }

  }

  function addRandomness(ball) {
    ball.dx += Math.random() * 0.01 - 0.005;
    ball.dy += Math.random() * 0.01 - 0.005;

    // Limit the speed of the ball
    ball.dx = Math.min(Math.max(ball.dx, -MAX_SPEED), MAX_SPEED);
    ball.dy = Math.min(Math.max(ball.dy, -MAX_SPEED), MAX_SPEED);

    // Make sure the ball always maintains a minimum speed
    if (Math.abs(ball.dx) < MIN_SPEED)
      ball.dx = ball.dx > 0 ? MIN_SPEED : -MIN_SPEED;
    if (Math.abs(ball.dy) < MIN_SPEED)
      ball.dy = ball.dy > 0 ? MIN_SPEED : -MIN_SPEED;
  }

  function getHexagons(level, size) {
    const res = [];
    for (let l = 0; l <= level; l++) {
      if (l === 0) {
        res.push({ i: res.length, x: 0, y: 0, color: NEITHER_COLOR });
      } else {
        for (let vertex = 0; vertex < 6; vertex++) {
          const x = 2 * l * size * Math.cos(2 * Math.PI / 6 * vertex);
          const y = 2 * l * size * Math.sin(2 * Math.PI / 6 * vertex);
          for (let dir = 0; dir < l; dir++) {
            const dx = 2 * dir * size * Math.cos(2 * Math.PI / 6 * vertex + 2 * Math.PI / 3);
            const dy = 2 * dir * size * Math.sin(2 * Math.PI / 6 * vertex + 2 * Math.PI / 3);
            res.push({ i: res.length, x: x + dx, y: y + dy, color: NEITHER_COLOR });
          }
        }
      }
    }

    // 外壁を作る
    const l = level + 1;
    for (let vertex = 0; vertex < 6; vertex++) {
      const x = 2 * l * size * Math.cos(2 * Math.PI / 6 * vertex);
      const y = 2 * l * size * Math.sin(2 * Math.PI / 6 * vertex);
      for (let dir = 0; dir < l; dir++) {
        const dx = 2 * dir * size * Math.cos(2 * Math.PI / 6 * vertex + 2 * Math.PI / 3);
        const dy = 2 * dir * size * Math.sin(2 * Math.PI / 6 * vertex + 2 * Math.PI / 3);
        res.push({ i: res.length, x: x + dx, y: y + dy, color: WALL_COLOR });
      }
    }
    return res;
  }

  function drawHexagon(x, y, size, color) {
    ctx.beginPath();
    for (let p = 0; p < 6; p++) {
      const t = 2 * Math.PI / 6 * p + Math.PI / 6;
      ctx.lineTo(x + size * Math.cos(t) / Math.cos(Math.PI / 6), y + size * Math.sin(t) / Math.cos(Math.PI / 6));
      // ctx.lineTo(x + size * Math.cos(2 * Math.PI / 6 * p), y + size * Math.sin(2 * Math.PI / 6 * p));
    }
    ctx.fillStyle = color;
    ctx.fill();
    ctx.closePath();
  }

  function drawHexMap() {
    dayScore = 0;
    nightScore = 0;

    hexagons.forEach((hexagon) => {
      drawHexagon(hexagon.x + canvas.width / 2, hexagon.y + canvas.height / 2, HEXAGON_SIZE, hexagon.color);
      if (hexagon.color === DAY_COLOR) dayScore++;
      if (hexagon.color === NIGHT_COLOR) nightScore++;
    });
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawHexMap();

    scoreElement.textContent = `day ${dayScore} | night ${nightScore}`;

    balls.forEach((ball) => {
      drawBall(ball);
      checkCollision(ball);
      ball.x += ball.dx;
      ball.y += ball.dy;

      addRandomness(ball);
    });

    iteration++;
    if (iteration % 1_000 === 0) console.log("iteration", iteration);
    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
</script>

</html>