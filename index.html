<!DOCTYPE html>
<html>

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pong wars | Koen van Gilst</title>
  <meta name="description"
    content="The eternal battle between day and night, good and bad. Written in JavaScript with some HTML & CSS in one index.html. Feel free to reuse the code and create your own version." />
  <link rel="canonical" href="https://pong-wars.koenvangilst.nl/" />
  <link rel="author" href="https://koenvangilst.nl" />
  <meta name="theme-color" content="#172B36" />
  <meta name="creator" content="Koen van Gilst" />
  <style>
    html {
      height: 100%;
    }

    body {
      height: 100%;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      background: linear-gradient(to bottom, #172b36 0%, #d9e8e3 100%);
    }

    #container {
      display: flex;
      align-items: center;
      flex-direction: column;
      width: min(70vh, 80%);
      max-width: 600px;
      height: 100%;
    }

    canvas {
      display: block;
      border-radius: 4px;
      overflow: hidden;
      width: 100%;
      margin-top: auto;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
    }

    #score {
      font-family: monospace;
      margin-top: 30px;
      font-size: 16px;
      padding-left: 20px;
      color: #172b36;
    }

    #made {
      text-align: center;
      line-height: 1.5;
      font-family: monospace;
      margin-top: auto;
      margin-bottom: 20px;
      font-size: 10px;
    }

    #made a {
      color: #172b36;
    }
  </style>
</head>

<body>
  <div id="container">
    <canvas id="pongCanvas" width="600" height="600"></canvas>
    <div id="score"></div>
    <p id="made">
      made by
      <a href="https://koenvangilst.nl/labs/pong-wars">Koen van Gilst</a> |
      source on
      <a href="https://github.com/vnglst/pong-wars">github</a>
    </p>
  </div>
</body>

<script>
  // Source palette: https://twitter.com/AlexCristache/status/1738610343499157872
  // Idea for Pong wars: https://twitter.com/nicolasdnl/status/1749715070928433161

  const colorPalette = {
    ArcticPowder: "#F1F6F4",
    MysticMint: "#D9E8E3",
    Forsythia: "#FFC801",
    DeepSaffron: "#FF9932",
    NocturnalExpedition: "#114C5A",
    OceanicNoir: "#172B36",
  };

  const canvas = document.getElementById("pongCanvas");
  const ctx = canvas.getContext("2d");
  const scoreElement = document.getElementById("score");

  const DAY_COLOR = colorPalette.MysticMint;
  const DAY_BALL_COLOR = colorPalette.NocturnalExpedition;
  const NIGHT_COLOR = colorPalette.NocturnalExpedition;
  const NIGHT_BALL_COLOR = colorPalette.MysticMint;
  const NEITHER_COLOR = colorPalette.ArcticPowder;
  const WALL_COLOR = colorPalette.DeepSaffron;
  const HEXAGON_SIZE = 15; // 隣の六角形との中心間距離
  const BALL_RADIUS = HEXAGON_SIZE / 5;
  const MIN_SPEED = 1;
  const MAX_SPEED = 3;

  const HEXAGON_MAP_LEVEL = 8;


  let dayScore = 0;
  let nightScore = 0;


  // hexagon: {i, x, y, color}
  const hexagons = getHexagons(HEXAGON_MAP_LEVEL, HEXAGON_SIZE);
  const numHexagons = hexagons.length;


  const balls = [
    {
      i: getMostClose(-canvas.width / 4, 0),
      x: -canvas.width / 4,
      y: 0,
      dx: 2,
      dy: 1,
      reverseColor: DAY_COLOR,
      ballColor: DAY_BALL_COLOR,
    },
    {
      i: getMostClose(canvas.width / 4, 0),
      x: canvas.width / 4,
      y: 0,
      dx: -1,
      dy: -2,
      reverseColor: NIGHT_COLOR,
      ballColor: NIGHT_BALL_COLOR,
    },
  ];

  let iteration = 0;


  function getMostClose(x, y) {
    let fst = Number.MAX_VALUE;
    let fsti = -1;
    for (let j = 0; j < numHexagons; j++) {
      const hex = hexagons[j];
      const dist = Math.sqrt((x - hex.x) ** 2 + (y - hex.y) ** 2);
      if (dist < fst) {
        fst = dist;
        fsti = j;
      }
    }
    return fsti;
  }

  function drawBall(ball) {
    ctx.beginPath();
    ctx.arc(ball.x + canvas.width / 2, ball.y + canvas.height / 2, BALL_RADIUS, 0, Math.PI * 2, false);
    ctx.fillStyle = ball.ballColor;
    ctx.fill();
    ctx.closePath();
  }


  function checkCollision(ball) {
    // 現在いる六角形の周囲の六角形との境界での衝突をチェック
    const current = hexagons[getMostClose(ball.x, ball.y)];

    let isBallOnEdge = false;

    for (let i = 0; i < 6; i++) {
      // (ball.x, ball.y)を(current.x, current.y)を中心にを反時計回りに60*i度回転させた点を(nx, ny)とする(ただしcurrentに対する位置)
      const nx = (ball.x - current.x) * Math.cos(Math.PI / 3 * i) - (ball.y - current.y) * Math.sin(Math.PI / 3 * i);

      // nx+BALL_RADIUS>HEXAGON_SIZE*sin(PI/12)なら衝突している
      isBallOnEdge |= nx + BALL_RADIUS > HEXAGON_SIZE;
    }

    if (isBallOnEdge) {
      // 衝突している六角形のインデックスを求める
      // 全ての六角形に対してボールとの距離を求め、二番目に距離が短いものを選ぶ（最小はcurrentなので）
      // (この実装は無理やりなので、余裕があれば修正する)

      let fst = Number.MAX_VALUE;
      let fsti = -1;
      let snd = Number.MAX_VALUE;
      let sndi = -1;
      for (let j = 0; j < numHexagons; j++) {
        const hex = hexagons[j];
        const dist = Math.sqrt((ball.x - hex.x) ** 2 + (ball.y - hex.y) ** 2);
        if (dist < fst) {
          snd = fst;
          sndi = fsti;
          fst = dist;
          fsti = j;
        } else if (dist < snd) {
          snd = dist;
          sndi = j;
        }
      }


      const next = hexagons[sndi];

      // next - currentのベクトル(= 壁の法線ベクトル)
      const nx = next.x - current.x;
      const ny = next.y - current.y;


      if (next.color === WALL_COLOR) {
        const { dx, dy } = reflectVector(ball.dx, ball.dy, nx, ny);
        ball.dx = dx;
        ball.dy = dy;
      } else if (next.color === NEITHER_COLOR) {
        next.color = ball.reverseColor;
      } else if (next.color !== ball.reverseColor) {
        next.color = ball.reverseColor;

        const { dx, dy } = reflectVector(ball.dx, ball.dy, nx, ny);
        ball.dx = dx;
        ball.dy = dy;
      }
    }
  }
  function reflectVector(dx, dy, nx, ny) {
    // 法線ベクトルを正規化する
    const length = Math.sqrt(nx * nx + ny * ny);
    const nxNormalized = nx / length;
    const nyNormalized = ny / length;

    // 速度ベクトルと法線ベクトルの内積を計算する
    const dot = dx * nxNormalized + dy * nyNormalized;

    // 反射後の速度ベクトルを計算する
    const dxPrime = dx - 2 * dot * nxNormalized;
    const dyPrime = dy - 2 * dot * nyNormalized;

    return { dx: dxPrime, dy: dyPrime };
  }

  function addRandomness(ball) {
    ball.dx += Math.random() * 0.01 - 0.005;
    ball.dy += Math.random() * 0.01 - 0.005;

    // Limit the speed of the ball
    ball.dx = Math.min(Math.max(ball.dx, -MAX_SPEED), MAX_SPEED);
    ball.dy = Math.min(Math.max(ball.dy, -MAX_SPEED), MAX_SPEED);

    // Make sure the ball always maintains a minimum speed
    if (Math.abs(ball.dx) < MIN_SPEED)
      ball.dx = ball.dx > 0 ? MIN_SPEED : -MIN_SPEED;
    if (Math.abs(ball.dy) < MIN_SPEED)
      ball.dy = ball.dy > 0 ? MIN_SPEED : -MIN_SPEED;
  }

  function getHexagons(level, size) {
    const res = [];
    for (let l = 0; l <= level; l++) {
      if (l === 0) {
        res.push({ i: res.length, x: 0, y: 0, color: NEITHER_COLOR });
      } else {
        for (let vertex = 0; vertex < 6; vertex++) {
          const x = 2 * l * size * Math.cos(2 * Math.PI / 6 * vertex);
          const y = 2 * l * size * Math.sin(2 * Math.PI / 6 * vertex);
          for (let dir = 0; dir < l; dir++) {
            const dx = 2 * dir * size * Math.cos(2 * Math.PI / 6 * vertex + 2 * Math.PI / 3);
            const dy = 2 * dir * size * Math.sin(2 * Math.PI / 6 * vertex + 2 * Math.PI / 3);
            res.push({ i: res.length, x: x + dx, y: y + dy, color: NEITHER_COLOR });
          }
        }
      }
    }

    // 外壁を作る
    const l = level + 1;
    for (let vertex = 0; vertex < 6; vertex++) {
      const x = 2 * l * size * Math.cos(2 * Math.PI / 6 * vertex);
      const y = 2 * l * size * Math.sin(2 * Math.PI / 6 * vertex);
      for (let dir = 0; dir < l; dir++) {
        const dx = 2 * dir * size * Math.cos(2 * Math.PI / 6 * vertex + 2 * Math.PI / 3);
        const dy = 2 * dir * size * Math.sin(2 * Math.PI / 6 * vertex + 2 * Math.PI / 3);
        res.push({ i: res.length, x: x + dx, y: y + dy, color: WALL_COLOR });
      }
    }
    return res;
  }

  function drawHexagon(x, y, size, color) {
    ctx.beginPath();
    for (let p = 0; p < 6; p++) {
      const t = 2 * Math.PI / 6 * p + Math.PI / 6;
      ctx.lineTo(x + size * Math.cos(t) / Math.cos(Math.PI / 6), y + size * Math.sin(t) / Math.cos(Math.PI / 6));
      // ctx.lineTo(x + size * Math.cos(2 * Math.PI / 6 * p), y + size * Math.sin(2 * Math.PI / 6 * p));
    }
    ctx.fillStyle = color;
    ctx.fill();
    ctx.closePath();
  }

  function drawHexMap() {
    dayScore = 0;
    nightScore = 0;

    hexagons.forEach((hexagon) => {
      drawHexagon(hexagon.x + canvas.width / 2, hexagon.y + canvas.height / 2, HEXAGON_SIZE, hexagon.color);
      if (hexagon.color === DAY_COLOR) dayScore++;
      if (hexagon.color === NIGHT_COLOR) nightScore++;
    });
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawHexMap();

    scoreElement.textContent = `day ${dayScore} | night ${nightScore}`;

    balls.forEach((ball) => {
      drawBall(ball);
      checkCollision(ball);
      // checkBoundaryCollision(ball);
      ball.x += ball.dx;
      ball.y += ball.dy;

      addRandomness(ball);
    });

    iteration++;
    if (iteration % 1_000 === 0) console.log("iteration", iteration);
    requestAnimationFrame(draw);
  }

  requestAnimationFrame(draw);
</script>

</html>